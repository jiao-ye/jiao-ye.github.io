<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PX4+gazebo+ros仿真</title>
    <url>/2025/12/12/PX4+gazebo+ros%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<h1 id="1-安装ROS"><a href="#1-安装ROS" class="headerlink" title="1.安装ROS"></a>1.安装ROS</h1><ul>
<li>安装ROS请查看另一篇文章：[安装ROS环境](<a href="https://jiao-ye.github.io/2025/12/08/windows%E4%BD%BF%E7%94%A8wsl2+ubuntu20.04%E5%AE%89%E8%A3%85ROS1%E7%9A%84%E6%AD%A5%E9%AA%A4/#more">windows使用wsl2+ubuntu20.04安装ROS1的步骤 | 角页</a>)</li>
</ul>
<h1 id="2-安装PX4仿真包"><a href="#2-安装PX4仿真包" class="headerlink" title="2.安装PX4仿真包"></a>2.安装PX4仿真包</h1><ul>
<li>克隆仓库，建议安装在~目录下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/PX4/PX4-Autopilot.git</span><br></pre></td></tr></table></figure>
<p><img src="/../../../images/Pasted%20image%2020251214150558.png"></p>
<ul>
<li>进入 PX4-Autopilot文件夹，安装依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd PX4-Autopilot/</span><br><span class="line">bash ./Tools/setup/ubuntu.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>在windows终端重启系统</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>
<ul>
<li>验证PX4+Gazebo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make px4_sitl gazebo</span><br></pre></td></tr></table></figure>
<p><img src="/../../../images/Pasted%20image%2020251214170614.png"><br>显示Gazebo界面则成功<br><img src="/../../../images/Pasted%20image%2020251214170710.png"></p>
<h1 id="3-安装mavlink"><a href="#3-安装mavlink" class="headerlink" title="3.安装mavlink"></a>3.安装mavlink</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-noetic-mavros ros-noetic-mavros-extras</span><br></pre></td></tr></table></figure>
<ul>
<li>安装地理包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /opt/ros/noetic/lib/mavros/install_geographiclib_datasets.sh</span><br></pre></td></tr></table></figure>
<h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><h2 id="4-1设置环境变量"><a href="#4-1设置环境变量" class="headerlink" title="4.1设置环境变量"></a>4.1设置环境变量</h2><ul>
<li>在此之前，要加入环境变量</li>
<li>编辑环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure>
<ul>
<li>加入以下内容<br><img src="/../../../images/Pasted%20image%2020251214171437.png"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/PX4-Autopilot/Tools/simulation/gazebo-classic/setup_gazebo.bash ~/PX4-Autopilot ~/PX4-Autopilot/build/px4_sitl_default</span><br><span class="line">export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4-Autopilot</span><br><span class="line">export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4-Autopilot/Tools/simulation/gazebo-classic/sitl_gazebo-classic</span><br></pre></td></tr></table></figure>

<h2 id="4-2启动"><a href="#4-2启动" class="headerlink" title="4.2启动"></a>4.2启动</h2><ul>
<li>一键启动PX4+gazebo+mavlink，在这里笔者启动带深度相机的launch文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch px4 mavros_posix_sitl.launch vehicle:=iris_depth_camera</span><br></pre></td></tr></table></figure>
<p><img src="/../../../images/Pasted%20image%2020251214171706.png"></p>
<ul>
<li>测试是否有话题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rostopic list</span><br></pre></td></tr></table></figure>
<p>成功<br><img src="/../../../images/Pasted%20image%2020251214171826.png"></p>
<h2 id="4-3测试起飞"><a href="#4-3测试起飞" class="headerlink" title="4.3测试起飞"></a>4.3测试起飞</h2><ul>
<li>在这里选择安装QGC地面站</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget https://github.com/mavlink/qgroundcontrol/releases/latest/download/QGroundControl.AppImage</span><br></pre></td></tr></table></figure>
<ul>
<li>赋予权限并启动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x QGroundControl.AppImage</span><br><span class="line">./QGroundControl.AppImage</span><br></pre></td></tr></table></figure>
<p><img src="/../../../images/Pasted%20image%2020251214172238.png"></p>
<ul>
<li>解锁飞机</li>
</ul>
<p><img src="/../../../images/Pasted%20image%2020251214172308.png"></p>
<ul>
<li>滑动解锁<br><img src="/../../../images/Pasted%20image%2020251214172328.png"></li>
<li>起飞<br><img src="/../../../images/Pasted%20image%2020251214172350.png"></li>
<li>成功起飞<br><img src="/../../../images/Pasted%20image%2020251214172438.png"></li>
</ul>
]]></content>
      <categories>
        <category>无人机</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>PX4</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32单片机下载显示failed to erase memory</title>
    <url>/2025/09/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8B%E8%BD%BD%E6%98%BE%E7%A4%BAfailed%20to%20erase%20memory/</url>
    <content><![CDATA[<p>在焊接新的芯片后下载程序显示下图<br><img src="/../../images/Pasted%20image%2020250915165612.png"><br>错误显示无法擦除扇区，连接ST-LINKUtility显示如下：<br><img src="/../../images/Pasted%20image%2020250915170058.png"><br>发现扇区0.1被锁住，取消勾选，再点击apply就行。我买的不是全新的吗？？？？？</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>BUCK电路详解</title>
    <url>/2025/02/26/BUCK%E7%94%B5%E8%B7%AF%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-什么是BUCK电路"><a href="#1-什么是BUCK电路" class="headerlink" title="1.什么是BUCK电路"></a>1.什么是BUCK电路</h1><ul>
<li>在如下回路中，通过不断的开关mos管，我们可以得到这样的电压波形<br><img src="/../images/Pasted%20image%2020250226174346.png"><br><img src="/../images/Pasted%20image%2020250226174516.png"></li>
</ul>
<h2 id="1-1有什么办法能让这个波形变得更加缓呢"><a href="#1-1有什么办法能让这个波形变得更加缓呢" class="headerlink" title="1.1有什么办法能让这个波形变得更加缓呢"></a>1.1有什么办法能让这个波形变得更加缓呢</h2><ul>
<li>我们可以想到，电容两端的电压不能突变，我们加上电容试试<br><img src="/../images/Pasted%20image%2020250226175122.png"><br>可以看到波形如下：<br><img src="/../images/Pasted%20image%2020250226175229.png"></li>
<li>可以看到，当开关断开时，电压并没有降为0，这是因为当开关闭合时，电源同时给负载和电容供电，当开关断开时，电容又会给负载供电，所以此时的电压不会为0，此时来看看电流的波形<br><img src="/../images/Pasted%20image%2020250226180138.png"></li>
<li>为什么会出现这个尖端呢，我们可以联想一下电容的公式：<br>$$ i(t) &#x3D; C \frac{dV(t)}{dt} $$</li>
<li>当t(时间)无限小时，此时的i(电流)是无限大的，这就是尖端产生的原因。</li>
</ul>
<h2 id="1-2有什么能让这个尖端变缓呢"><a href="#1-2有什么能让这个尖端变缓呢" class="headerlink" title="1.2有什么能让这个尖端变缓呢"></a>1.2有什么能让这个尖端变缓呢</h2><ul>
<li><p>可以很自然的想到，电感的电流是不可以突变的，我们加上电感试试，但由于当开关断开是，电感的左侧是开路的，我们需要构成一个回路，当开关闭合时，这个回路是断开的，开关断开是，这个回路是闭合的，可以想到用一个二极管放置在回路中，这就叫异步BUCK，既然有异步，那肯定就有同步，将一个MOS管代替二极管的位置，同时将控制开关的信号接一个反相器来控制MOS管，这时，当开关打开时，信号经过反相器就会将MOS管截止，反之就会打开。</p>
</li>
<li><p>下面是同步BUCK的示例<br><img src="/../images/Pasted%20image%2020250226195201.png"></p>
</li>
<li><p>在这里电源电压设置为10V，占空比设为0.5，理论值应为5V<br><img src="/../images/Pasted%20image%2020250226195734.png"><br>可以看到与理论值相差不大</p>
</li>
</ul>
<p>异步BUCK结构拓补图<br><img src="/../images/Pasted%20image%2020250226201507.png"><br>同步BUCK结构拓补图<br><img src="/../images/Pasted%20image%2020250226201559.png"></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>电路</tag>
        <tag>DC-DC</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32G431启用FPU与DSP库</title>
    <url>/2025/09/22/STM32G431%E5%90%AF%E7%94%A8FPU%E4%B8%8EDSP%E5%BA%93/</url>
    <content><![CDATA[<h1 id="1-FPU与DSP"><a href="#1-FPU与DSP" class="headerlink" title="1.FPU与DSP"></a>1.FPU与DSP</h1><ul>
<li>STM32的FPU是芯片内部的硬件浮点运算单元，能高速处理所有浮点计算；而DSP库则是建立在FPU等硬件特性之上的软件函数库，它提供了一系列经过极致优化的数字信号处理算法（如FFT、滤波等）。两者关系可概括为：FPU是强大的硬件基础，负责通用浮点加速；DSP库则是专业的软件加速包，针对复杂算法进行特定优化。在实际应用中，应先启用FPU获得基础性能提升，再调用DSP库来处理专门的复杂运算任务。</li>
<li>下面我们通过STM32CUBEMX + cmake  + vscode 来创建一个完整地项目</li>
</ul>
<h1 id="2-工程创建"><a href="#2-工程创建" class="headerlink" title="2.工程创建"></a>2.工程创建</h1><h2 id="2-1新建STMG431CBT6的工程"><a href="#2-1新建STMG431CBT6的工程" class="headerlink" title="2.1新建STMG431CBT6的工程"></a>2.1新建STMG431CBT6的工程</h2><p><img src="/../../images/Pasted%20image%2020250923155732.png"></p>
<ul>
<li>选择外部高速时钟<br><img src="/../../images/Pasted%20image%2020250923160215.png"></li>
<li>开启SWD，就是允许我们使用ST-link进行下载调试，时钟来源选择系统时钟<br><img src="/../../images/Pasted%20image%2020250923161121.png"></li>
<li>因为我们要用到串口打印相关信息，开启串口2</li>
<li><img src="/../../images/Pasted%20image%2020250923161436.png"></li>
<li>配置时钟，按照自己的晶振频率设置<br><img src="/../../images/Pasted%20image%2020250923161706.png"></li>
<li>配置相关项目相关信息<br>项目名称，开发工具，固件版本<br><img src="/../../images/Pasted%20image%2020250923161903.png"><br>生成源文件和头文件 ，生成项目<br><img src="/../../images/Pasted%20image%2020250923162323.png"></li>
</ul>
<h2 id="2-2用VSCODE打开并编译看是否成功"><a href="#2-2用VSCODE打开并编译看是否成功" class="headerlink" title="2.2用VSCODE打开并编译看是否成功"></a>2.2用VSCODE打开并编译看是否成功</h2><p>导入Cmake项目，选择刚生成的文件打开，直接导入即可<br><img src="/../../images/Pasted%20image%2020250923165558.png"><br>点击编译，输出如下信息显示成功<br><img src="/../../images/Pasted%20image%2020250923165728.png"></p>
<h2 id="2-3开启FPU并且添加DSP库"><a href="#2-3开启FPU并且添加DSP库" class="headerlink" title="2.3开启FPU并且添加DSP库"></a>2.3开启FPU并且添加DSP库</h2><ul>
<li>回到CUBEMX<br><img src="/../../images/Pasted%20image%2020250923170055.png"></li>
<li>找到DSP库，并且勾选上，可能下载会比较慢<br><img src="/../../images/Pasted%20image%2020250923170334.png"><br>返回，并且勾选上添加DSP库，生成代码<br><img src="/../../images/Pasted%20image%2020250923171004.png"><br>返回Vscode看到有如下文件则添加成功<br><img src="/../../images/Pasted%20image%2020250923171138.png"><br>接下来在CMake文件中如下位置添加两行代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/Drivers/CMSIS/DSP/Lib/GCC/libarm_cortexM4lf_math.a</span><br><span class="line">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/Drivers/CMSIS/DSP/Include</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250923171646.png"><br>到此，工程创建成功</p>
<h1 id="3-测试工程"><a href="#3-测试工程" class="headerlink" title="3.测试工程"></a>3.测试工程</h1><p>为了方便输出信息，我们将串口重定向，在usart.c文件中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef __GNUC__</span><br><span class="line"></span><br><span class="line">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  // 阻塞方式打印 -&gt; 串口2</span><br><span class="line"></span><br><span class="line">  HAL_UART_Transmit(&amp;huart2, (uint8_t *)&amp;ch, 1, 0xFFFF);</span><br><span class="line"></span><br><span class="line">  return ch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>&#x3D;&#x3D;注意要在gcc-arm-none-eabi.cmake文件如下位置加入-u_printf_float&#x3D;&#x3D;<br><img src="/../../images/Pasted%20image%2020250925165625.png"></li>
</ul>
<p>测试代码，注意需要包含stdio头文件<br><img src="/../../images/Pasted%20image%2020250923172715.png"><br>该插件的下载按钮如下<br><img src="/../../images/Pasted%20image%2020250923173120.png"><br>&#x3D;&#x3D;注意，必须加“\n”,不然会有莫名的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;hello\n&quot;);</span><br></pre></td></tr></table></figure>
<p>调试信息如下：<br><img src="/../../images/Pasted%20image%2020250925170045.png"><br>成功&#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32时钟树</title>
    <url>/2025/05/11/STM32%E6%97%B6%E9%92%9F%E6%A0%91/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><ul>
<li>在对STM32编程时，代码第一步总是要开启外设时钟使能，在数据手册上可以看到所有外设都是挂载在时钟树下，所以时钟树到底是个什么玩意？本文在此介绍。</li>
</ul>
<h1 id="2-时钟树"><a href="#2-时钟树" class="headerlink" title="2.时钟树"></a>2.时钟树</h1><ul>
<li>首先解释一下什么是时钟树，STM32的时钟树(Clock Tree)是指控制器内部时钟信号从源头到各个外设的分配和控制系统。它是一个复杂的网络结构，决定了CPU、总线和外设的工作频率。</li>
</ul>
<h2 id="2-1时钟的种类"><a href="#2-1时钟的种类" class="headerlink" title="2.1时钟的种类"></a>2.1时钟的种类</h2><ul>
<li>从数据手册可以看出，STM32系列的单片机又有四个基础时钟源，<strong>HSI振荡器时钟，LSI振荡器时钟，HSE振荡器时钟，HSI振荡器时钟</strong>，这四个时钟就是最基本的时钟来源，也就是时钟树的根，之后就是<strong>PLL锁相环</strong>和<strong>SYSCLK系统时钟</strong>。</li>
<li>这几者的关系可以先看成这样的关系<br><img src="/../images/Pasted%20image%2020250513211843.png"></li>
<li>我们直接查看数据手册<br><img src="/../images/Pasted%20image%2020250513212416.png"><br>可以看到外设的最高频率可以达到170M，显然可以看到这四个基础时钟都无法直接提供170M的频率，那么这170M的时钟是哪来的呢？从上面的关系图可以看出，将HSE或者HSI接入PLL就能输出170M的频率了。</li>
<li>系统时钟的来源：HSI振荡器时钟 HSE振荡器时钟 PLL锁相环  ，</li>
<li>两个次级时钟源：LSI振荡器时钟 LSE振荡器时钟</li>
</ul>
<h2 id="2-2时钟树的框图"><a href="#2-2时钟树的框图" class="headerlink" title="2.2时钟树的框图"></a>2.2时钟树的框图</h2><p><img src="/../images/Pasted%20image%2020250513213131.png"><br>乍一看很复杂，但我们不需要看这么多，我们将其简化一下，只需要看红色部分就行<br><img src="/../images/Pasted%20image%2020250513215153.png"></p>
<ul>
<li>LSI(内部低速时钟)：时钟信号由内部RC振荡电路产生，频率为32.768K</li>
<li>HSI(内部高速时钟)：时钟信号由内部RC振荡电路产生，STM32G431有两个时钟源(16M和48M)，一般用于独立看门狗</li>
<li>LSE(外部低速时钟)：时钟信号由外部晶振提供，一般为32.768K，一般用于RTC实时时钟</li>
<li>HSE(外部高速时钟)：时钟信号由外部晶振提供，范围为4-48M，主要是用该时钟</li>
<li>PLL锁相环：将时钟的信号进行放大<br> 简单介绍PLL锁相环，先看PLL的框图：<br> <img src="/../images/Pasted%20image%2020250909172639.png"><br>  鉴相器：通过比较输入输出的相位差，输出一定的电压信号<br>  低通滤波：滤除鉴相器输出的杂波<br>  压控振荡器：使输出信号的频率与低通滤波输出的频率保持一致<br>  那么我们只要在反馈通道上加上一个分频器，就能实现输出信号的放大</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode开发STM32G431使用串口重定向</title>
    <url>/2025/06/03/Vscode%E5%BC%80%E5%8F%91STM32G431%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<ul>
<li>在Vscode中使用STM32 VS Code Extension来开发STM32G431不同于keil，在keil中，我们只要勾选MicroLIB就能实现串口重定向<br><img src="/../images/Pasted%20image%2020250603222055.png"></li>
<li>在Vscode中我们要在STM32cubemx生成的代码下，在usart.c文件中加入如下代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;//包含头文件</span><br><span class="line"></span><br><span class="line">#ifdef __GNUC__</span><br><span class="line"></span><br><span class="line">  #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">  #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> PUTCHAR_PROTOTYPE</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;ch,1,0xFFFF);//阻塞方式打印</span><br><span class="line"></span><br><span class="line">  return ch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：使用printf函数时，必须在末尾加上\r\n，否则无法输出</p>
]]></content>
      <categories>
        <category>STM32</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>STM32G431</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题的使用</title>
    <url>/2025/02/22/next%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-主题类型设置"><a href="#1-主题类型设置" class="headerlink" title="1.主题类型设置"></a>1.主题类型设置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes 主题类型设置</span><br><span class="line"></span><br><span class="line"># scheme: Muse</span><br><span class="line"></span><br><span class="line">#scheme: Mist</span><br><span class="line"></span><br><span class="line">#scheme: Pisces</span><br><span class="line"></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
<p>有四个类型</p>
<h1 id="2-菜单栏"><a href="#2-菜单栏" class="headerlink" title="2.菜单栏"></a>2.菜单栏</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"></span><br><span class="line">  home: / || fa fa-home #主页</span><br><span class="line"></span><br><span class="line">  #about: /about/ || fa fa-user</span><br><span class="line"></span><br><span class="line">  tags: /tags/ || fa fa-tags #标签页</span><br><span class="line"></span><br><span class="line">  categories: /categories/ || fa fa-th #种类页</span><br><span class="line"></span><br><span class="line">  archives: /archives/ || fa fa-archive #日志页</span><br><span class="line"></span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line"></span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line"></span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>
<p>打开后，在myBlog\source路径下新建tags与categories文件夹，并在文件夹下建立index.md文件，<br>tags下index文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: 标签</span><br><span class="line"></span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line"></span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>categories下index文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: 种类</span><br><span class="line"></span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line"></span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1 id="3-修改主页头像"><a href="#3-修改主页头像" class="headerlink" title="3.修改主页头像"></a>3.修改主页头像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line"></span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line"></span><br><span class="line">  url: /images/jiaoye.gif #在这里填入你头像的路径 头像格式为215 X 215</span><br><span class="line"></span><br><span class="line">  # If true, the avatar will be displayed in circle.</span><br><span class="line"></span><br><span class="line">  rounded: false</span><br><span class="line"></span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line"></span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>
<h1 id="4-开启搜索功能"><a href="#4-开启搜索功能" class="headerlink" title="4.开启搜索功能"></a>4.开启搜索功能</h1><ul>
<li>安装插件<code>hexo-generator-searchdb</code>,执行以下命令:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<ul>
<li>修改hexo&#x2F;config.yml配置内容，新增以下内容到任意位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑 主题配置文件，启用本地搜索功能：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">enable: true</span><br></pre></td></tr></table></figure>



<h1 id="5-开启评论功能"><a href="#5-开启评论功能" class="headerlink" title="5.开启评论功能"></a>5.开启评论功能</h1><h2 id="5-1-建立一个新的github仓库"><a href="#5-1-建立一个新的github仓库" class="headerlink" title="5.1 建立一个新的github仓库"></a>5.1 建立一个新的github仓库</h2><p><img src="/../images/Pasted%20image%2020251214195244.png"></p>
<ul>
<li>在仓库设置里打开discussions功能<br><img src="/../images/Pasted%20image%2020251214195444.png"></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建个人博客推送至github</title>
    <url>/2025/02/21/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8E%A8%E9%80%81%E8%87%B3github/</url>
    <content><![CDATA[<h1 id="1-安装git与Nodejs"><a href="#1-安装git与Nodejs" class="headerlink" title="1.安装git与Nodejs"></a>1.安装git与Nodejs</h1><ul>
<li><p>在Windows上安装Git，可以从Git官网直接<a href="https://git-scm.com/downloads%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8C%89%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9%E5%AE%89">https://git-scm.com/downloads，然后按默认选项安</a><br>装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就<br>说明Git安装成功。<br><img src="/../../images/Pasted%20image%2020250221215415.png"></p>
</li>
<li><p>在Git中绑定Github账号，打开“Git Bash”，在命令框中依次输入两行命令：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br><span class="line"># 其中Your Name和email@example.com替换成github账户名和邮箱</span><br></pre></td></tr></table></figure>
<ul>
<li>安装NodeJS<br>网址 <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> 并配置环境变量。</li>
<li>安装之后可以输入以下命令查看是否安装成功。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250221220038.png"></p>
<h1 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h1><ul>
<li>新建文件夹，在该文件夹下打开”git bach here“。<br><img src="/../../images/Pasted%20image%2020250221220553.png"></li>
<li>在命令行执行下列命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<ul>
<li>执行完成后，运行 hexo server 命令，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就能够预览效果了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250221220910.png"></p>
<h1 id="3-修改主题"><a href="#3-修改主题" class="headerlink" title="3.修改主题"></a>3.修改主题</h1><ul>
<li>我用的是NEXT主题：<a href="https://github.com/next-theme/hexo-theme-next%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%9C%A8myBlog/themes%E8%B7%AF%E5%BE%84%E4%B8%8B%E3%80%82%E7%84%B6%E5%90%8E%E6%89%93%E5%BC%80_config.yml%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%A6%82%E4%B8%8B%E3%80%82">https://github.com/next-theme/hexo-theme-next，下载完成后解压在myBlog\themes路径下。然后打开_config.yml文件修改如下。</a><br><img src="/../../images/Pasted%20image%2020250221221700.png"><br>这里为了简便我将解压后的文件重命名为next，保存之后刷新 <a href="http://localhost:4000/">http://localhost:4000</a> 页面，主题就已经更改完成。</li>
</ul>
<h1 id="4-修改next主题配置"><a href="#4-修改next主题配置" class="headerlink" title="4.修改next主题配置"></a>4.修改next主题配置</h1><ul>
<li>详细配置请见</li>
</ul>
<h1 id="5-将博客部署在github上"><a href="#5-将博客部署在github上" class="headerlink" title="5.将博客部署在github上"></a>5.将博客部署在github上</h1><ul>
<li>在github上建立一个新仓库，在这里注意仓库名一定要是： 用户名.github.io，如我的用户名是jiao-ye，那么我的新仓库名就为jiao-ye.github.io</li>
<li>配置 SSH key ，要使用 git 工具首先要配置一下SSH key，将本地仓库能连接远程仓库，输入下列命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#email@example.com替换成github邮箱</span><br></pre></td></tr></table></figure>
<p>按照提示完成后便可以生成ssh key。<br>查看ssh key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250221223544.png"><br>复制输出的ssh key，在github上建立新的ssh key<br><img src="/../../images/Pasted%20image%2020250221223704.png"><br><img src="/../../images/Pasted%20image%2020250221223713.png"></p>
<ul>
<li>将本地仓库与远程仓库连接起来，打开_config.yml文件进行如下修改<br><img src="/../../images/Pasted%20image%2020250221223919.png"><br><img src="/../../images/Pasted%20image%2020250221223957.png"></li>
<li>安装部署插件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ul>
<li>执行如下两条指令生成与部署</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g # 生成</span><br><span class="line">hexo d # 部署到Github上</span><br></pre></td></tr></table></figure>
<ul>
<li>用浏览器输入 用户名.github.io 就可以访问自己的个人博客了</li>
</ul>
<h1 id="6-编写shell脚本方便部署"><a href="#6-编写shell脚本方便部署" class="headerlink" title="6.编写shell脚本方便部署"></a>6.编写shell脚本方便部署</h1><ul>
<li>在myBlog下新建deploy.sh脚本，粘贴下列代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成静态文件</span><br><span class="line">hexo clean &amp;&amp; hexo generate</span><br><span class="line"></span><br><span class="line"># 部署到 GitHub Pages</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>给与权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+x deploy.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>双击deploy.sh即可一键部署<br><img src="/../../images/Pasted%20image%2020250221224633.png"></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>Obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>windows使用wsl2+ubuntu20.04安装ROS1的步骤</title>
    <url>/2025/12/08/windows%E4%BD%BF%E7%94%A8wsl2+ubuntu20.04%E5%AE%89%E8%A3%85ROS1%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="1-首先确保电脑CPU能虚拟化并且打开如下功能"><a href="#1-首先确保电脑CPU能虚拟化并且打开如下功能" class="headerlink" title="1.首先确保电脑CPU能虚拟化并且打开如下功能"></a>1.首先确保电脑CPU能虚拟化并且打开如下功能</h1><p><img src="/../../images/Pasted%20image%2020251208111118.png"></p>
<p><img src="/../../images/Pasted%20image%2020251208110347.png"></p>
<h1 id="2-安装wsl2与ubuntu20-04"><a href="#2-安装wsl2与ubuntu20-04" class="headerlink" title="2.安装wsl2与ubuntu20.04"></a>2.安装wsl2与ubuntu20.04</h1><h2 id="2-1安装WSL2"><a href="#2-1安装WSL2" class="headerlink" title="2.1安装WSL2"></a>2.1安装WSL2</h2><ul>
<li>在power shell里输入wsl–install，安装完成后显示&#96;适用于 Linux 的 Windows 子系统已安装</li>
<li>输入wsl.exe –update，进度条完成后即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br><span class="line">wsl.exe --update</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020251208120609.png"></p>
<h2 id="2-2安装Ubuntu20-04"><a href="#2-2安装Ubuntu20-04" class="headerlink" title="2.2安装Ubuntu20.04"></a>2.2安装Ubuntu20.04</h2><ul>
<li>直接在store安装，选择20.04版本<br><img src="/../../images/Pasted%20image%2020251208110517.png"></li>
<li>安装完成后，打开终端输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<p>看是否有如下输出<br><img src="/../../images/Pasted%20image%2020251208110702.png"><br>注意：如果VERSION显示的是1.那么输入以下命令将wsl1切换成wsl2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --set-version Ubuntu-20.04 2 </span><br></pre></td></tr></table></figure>
<ul>
<li>切换成功后，在终端打开Ubuntu20.04<br><img src="/../../images/Pasted%20image%2020251208111709.png"><br>首次登录要输入用户和密码，打开后显示<br><img src="/../../images/Pasted%20image%2020251208111813.png"><br>安装完成</li>
</ul>
<h1 id="3-安装ROS"><a href="#3-安装ROS" class="headerlink" title="3.安装ROS"></a>3.安装ROS</h1><h2 id="3-1必要准备"><a href="#3-1必要准备" class="headerlink" title="3.1必要准备"></a>3.1必要准备</h2><ul>
<li>在命令行输入以下命令，修改镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<ul>
<li>输入ggdG删除原本镜像源<br><img src="/../../images/Pasted%20image%2020251208142046.png"></li>
<li>粘贴中科大镜像源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/Pasted%20image%2020251208142323.png"></p>
<ul>
<li>输入wq保存退出</li>
<li>在终端输入中科大的安装镜像源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure>
<p>**<img src="/../../images/Pasted%20image%2020251208142353.png"></p>
<ul>
<li>设置key</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020251208142439.png"></p>
<ul>
<li>更新apt</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>这里出现网络问题<br><img src="/../../images/Pasted%20image%2020251208143138.png"><br>解决办法</p>
<ul>
<li>1.在ubuntu中执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/wsl.conf</span><br></pre></td></tr></table></figure>
<p>在wsl.config文件中另外加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf = false</span><br></pre></td></tr></table></figure>
<ul>
<li>2.删除并手动创建 &#x2F;etc&#x2F;resolv.conf</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm /etc/resolv.conf</span><br><span class="line">sudo vim /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>3.写入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 119.29.29.29</span><br></pre></td></tr></table></figure>
<ul>
<li>4.重启wsl，在powershell里输入wsl – shutdown重启<br>更新成功<br><img src="/../../images/Pasted%20image%2020251208145332.png"></li>
</ul>
<h2 id="3-2安装ROS"><a href="#3-2安装ROS" class="headerlink" title="3.2安装ROS"></a>3.2安装ROS</h2><ul>
<li>输入命令，安装可能费时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure>
<ul>
<li>注意，笔者并没有遇到安装不上问题，不知道是运气好还是啥，测试过很多次，都是一次成功<br><img src="/../images/Pasted%20image%2020251208151916.png"></li>
<li>配置环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<ul>
<li>安装依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br></pre></td></tr></table></figure>
<p><img src="/../images/Pasted%20image%2020251208152202.png"></p>
<h2 id="3-3初始化"><a href="#3-3初始化" class="headerlink" title="3.3初始化"></a>3.3初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure>
<p>如下输出则安装成功<br><img src="/../images/Pasted%20image%2020251208152415.png"><br><img src="/../images/Pasted%20image%2020251208152428.png"></p>
<h1 id="4-测试ROS"><a href="#4-测试ROS" class="headerlink" title="4.测试ROS"></a>4.测试ROS</h1><ul>
<li>打开三个终端<br><img src="/../images/Pasted%20image%2020251208152536.png"></li>
<li>每个终端分别输入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roscore(启动核心)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rosrun turtlesim turtlesim_node(测试小乌龟界面节点)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rosrun turtlesim turtle_teleop_key(测试控制小乌龟运动节点)</span><br></pre></td></tr></table></figure>
<p>roscore<br><img src="/../images/Pasted%20image%2020251208161347.png"><br>rosrun turtlesim turtlesim_node<br><img src="/../images/Pasted%20image%2020251208161403.png"><br>rosrun turtlesim turtle_teleop_key:<br><img src="/../images/Pasted%20image%2020251208161413.png"><br>将光标移动到执行key的终端，通过方向键控制小乌龟的行动<br><img src="/../images/Pasted%20image%2020251208161457.png"><br>测试完成</p>
]]></content>
      <categories>
        <category>无人机</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>串联谐振与并联谐振</title>
    <url>/2025/03/03/%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF%E4%B8%8E%E5%B9%B6%E8%81%94%E8%B0%90%E6%8C%AF/</url>
    <content><![CDATA[<h1 id="1-什么是谐振？"><a href="#1-什么是谐振？" class="headerlink" title="1.什么是谐振？"></a>1.什么是谐振？</h1><h2 id="1-1RLC串联谐振"><a href="#1-1RLC串联谐振" class="headerlink" title="1.1RLC串联谐振"></a>1.1RLC串联谐振</h2><ul>
<li><p>对于一个RLC串联电路，如果端电压与端电流同相位，则称该电路发生了谐振<br><img src="/../images/Pasted%20image%2020250303235346.png"></p>
</li>
<li><p>电路的阻抗为<br> $$ Z &#x3D; R + j\left( \omega L - \frac{1}{\omega C} \right) $$<br> 从上面可以看出阻抗具有虚部，那么端口电压与端口电流的相位肯定不是相同的，相差一个阻抗角</p>
</li>
<li><p>我们知道，流经电阻的电压和电流是相位相同的，那么我们是否可以把该电路的阻抗等效成一个电阻呢，当然可以，只需要令<br> $$ \left( \omega L - \frac{1}{\omega C} \right)&#x3D;0 $$<br> 此时该电路的阻抗就等效为R</p>
</li>
<li><p>可以求得：<br> $$ w &#x3D; \frac{1}{\sqrt{LC}} $$</p>
</li>
</ul>
<p> 当上式成立时，此时该电路就发生了谐振。</p>
<ul>
<li>如果我们变化这个频率，电路会怎样变化，w增大，可以推出<br>$$ \left( \omega L - \frac{1}{\omega C} \right)&gt;0 $$<br> 那么此时的阻抗角<br> $$\theta &#x3D; \arctan\left(\frac{X}{R}\right)&gt;0$$<br> 可以得出电压超前电流，那么此时该电路呈现出感性，反之则呈现出容性，此时电容与电感的总电压为0，但电容与电感两端的电压却不是为0，而是具有这样的特点：大小相同，方向相反</li>
</ul>
<h2 id="1-2RLC并联谐振"><a href="#1-2RLC并联谐振" class="headerlink" title="1.2RLC并联谐振"></a>1.2RLC并联谐振</h2><ul>
<li>对于RLC并联谐振也是一样的，为了方便，我们用导纳来表示<br><img src="/../images/Pasted%20image%2020250304003015.png"></li>
<li>电路的导纳为<br> $$ Y &#x3D; G + j\left( \omega C - \frac{1}{\omega L} \right) $$<br> 一样的我们令<br> $$ \left( \omega C - \frac{1}{\omega L} \right)&#x3D;0 $$<br> 此时电路的导纳就等效为G，端电流与端电压的相位就相同了</li>
<li>同样可以求得<br>  $$ w &#x3D; \frac{1}{\sqrt{LC}} $$</li>
<li>如果我们改变这个频率，令w增大，那么可以推出<br>   $$ \left( \omega C - \frac{1}{\omega L} \right)&gt;0 $$<br>   此时电流的相位超前电压，电路呈现容性，反之呈现感性。此时电容与电感的总电流为0，但电容与电感所在的支路电流却不是为0，而是具有这样的特点：大小相同，方向相反</li>
</ul>
<h2 id="1-3谐振的特性"><a href="#1-3谐振的特性" class="headerlink" title="1.3谐振的特性"></a>1.3谐振的特性</h2><ul>
<li>对于RLC串联电路，我们可由阻抗的模值等于<br>$$|Z| &#x3D; \sqrt{R^2 + X^2}$$<br>此时的电流等于<br>$$I &#x3D; \frac{U}Z$$<br>可知当阻抗最小时，电流最大，那么什么时候阻抗最小，如果X等于0，那么|Z|就最小，也就是发生谐振的时候，所以RLC串联电路发生谐振时，电路的电流是最大的</li>
<li>同理我们可以推出RLC并联电路发生谐振时，电路的电流是最小的</li>
</ul>
<h2 id="1-4品质因数"><a href="#1-4品质因数" class="headerlink" title="1.4品质因数"></a>1.4品质因数</h2><ul>
<li>在RLC串联谐振中，品质因数的定义是电容或电感的电压与电源的比值<br>$$Q &#x3D; \frac{w L}{R} &#x3D; \frac{1}{w C R}&#x3D;\frac{1}{R} \sqrt{\frac{L}{C}}$$<br>可以看到电路的品质因数由RLC的参数决定，如果Q大于0，则说明电容&#x2F;电感两端的电压大于电源电压，这就叫做”过电压“，在实际中，我们应该避免过电压的产生</li>
<li>在RLC并联谐振中，品质因数的定义是电容或电感的支路电流与干路电流的比值 $$<br>Q &#x3D; \frac{1}{G} \sqrt{\frac{C}{L}}$$<br>可以看到电路的品质因数也是由RLC的参数决定，如果Q大于0，则说明电容&#x2F;电感的支路电流大于干路电流，这就叫做”过电流“</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Cmake+hal库开发STM32无法通过printf打印浮点数</title>
    <url>/2025/09/16/%E4%BD%BF%E7%94%A8Cmake+hal%E5%BA%93%E5%BC%80%E5%8F%91STM32%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87printf%E6%89%93%E5%8D%B0%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<p>在开发STM32中，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    printf(&quot;angle = %d&quot;, angle);</span><br><span class="line"></span><br><span class="line">    printf(&quot;angle = %f\n&quot;, angle_f);</span><br><span class="line">  注意，最后打印字符时必须要加上换行符，否则会出错</span><br></pre></td></tr></table></figure>
<p>输出界面：<br><img src="/../images/Pasted%20image%2020250916104932.png"><br>可以看到浮点数并没有被打印出来，我们只需要在.cmake文件中加入-u_printf_float<br><img src="/../images/Pasted%20image%2020250916105907.png"><br>重新编译下载<br><img src="/../images/Pasted%20image%2020250916110026.png"><br>正常打印浮点数，但此时占用的FLASH较多，建议不需要时关闭</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>解决STM32G431BOOT0与IIC冲突问题</title>
    <url>/2025/06/04/%E8%A7%A3%E5%86%B3STM32G431BOOT0%E4%B8%8EIIC%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>在STM32G431中，启动时选择主Flash启动，此时需要将BOOT0引脚拉低为低电平，但此时BOOT0引脚作为IIC外挂了4.7k电阻，此时不可能将引脚拉低。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>STM32G431</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Obsidian来编写hexo博客</title>
    <url>/2025/02/21/%E4%BD%BF%E7%94%A8Obsidian%E6%9D%A5%E7%BC%96%E5%86%99hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="1-下载Obsidian"><a href="#1-下载Obsidian" class="headerlink" title="1.下载Obsidian"></a>1.下载Obsidian</h1><ul>
<li>在官网下载Obsidian：<a href="https://obsidian.md/">https://obsidian.md/</a><br><img src="/../../images/Pasted%20image%2020250221230923.png"><br>按照提示安装，最好将目标位置改为D盘</li>
<li>安装完成，选择打开myBlog文件夹<br><img src="/../../images/Pasted%20image%2020250221231158.png"></li>
</ul>
<h1 id="2-配置Obsidian"><a href="#2-配置Obsidian" class="headerlink" title="2.配置Obsidian"></a>2.配置Obsidian</h1><ul>
<li>点击Obsidian的设置<br><img src="/../../images/Pasted%20image%2020250221231614.png"></li>
<li>点击文件与链接，忽略以下文件<br><img src="/../../images/Pasted%20image%2020250221231806.png"></li>
<li>在myBlog\source下新建images文件夹，将内部链接类型改为基于当前笔记的相对路径，关闭wiki链接，将附件默认存放路径改为指定的附件文件夹，将附件文件夹路径改为source&#x2F;images<br><img src="/../../images/Pasted%20image%2020250221232138.png"></li>
<li>将新建笔记的存放位置改为指定的附件文件夹，将存放新建笔记的文件<br><img src="/../../images/Pasted%20image%2020250221232446.png"></li>
</ul>
<h1 id="3-安装插件"><a href="#3-安装插件" class="headerlink" title="3.安装插件"></a>3.安装插件</h1><ul>
<li>关闭安全模式，在插件市场下载如下四个插件<br><img src="/../images/Pasted%20image%2020250222161719.png"></li>
</ul>
<h2 id="3-1-git、float-toc、tree下载无需配置"><a href="#3-1-git、float-toc、tree下载无需配置" class="headerlink" title="3.1 git、float toc、tree下载无需配置"></a>3.1 git、float toc、tree下载无需配置</h2><h2 id="3-2-Shell插件配置"><a href="#3-2-Shell插件配置" class="headerlink" title="3.2 Shell插件配置"></a>3.2 Shell插件配置</h2><ul>
<li>点击New shell command，创建新的命令</li>
<li>写入start deploy.sh命令，该脚本在已经在<a href="/2025/02/21/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8E%A8%E9%80%81%E8%87%B3github/" title="hexo搭建个人博客推送至github">hexo搭建个人博客推送至github</a>中创建<br> <img src="/../images/Pasted%20image%2020250222162125.png"></li>
<li>点击执行按钮，就会自动部署到远程仓库</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>Obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>无人机悬停时间计算方法</title>
    <url>/2025/10/23/%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%82%AC%E5%81%9C%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-计算电机转速N和螺旋桨转矩M轴距"><a href="#1-计算电机转速N和螺旋桨转矩M轴距" class="headerlink" title="1.计算电机转速N和螺旋桨转矩M轴距"></a>1.计算电机转速N和螺旋桨转矩M轴距</h1><h2 id="1-1轴距"><a href="#1-1轴距" class="headerlink" title="1.1轴距"></a>1.1轴距</h2><ul>
<li>对角线方向上两个电机中心之间的直线距离，轴距越短，对飞控的精度要求就更高</li>
</ul>
<h2 id="1-2拉力"><a href="#1-2拉力" class="headerlink" title="1.2拉力"></a>1.2拉力</h2><ul>
<li>由整机的重量来计算单个螺旋桨需要的拉力</li>
</ul>
<p>$$<br>T &#x3D; \frac{G}{n}<br>$$</p>
<ul>
<li>G是重力，n是螺旋桨个数</li>
</ul>
<h2 id="1-3计算转速N"><a href="#1-3计算转速N" class="headerlink" title="1.3计算转速N"></a>1.3计算转速N</h2><h3 id="大气压强计算公式"><a href="#大气压强计算公式" class="headerlink" title="大气压强计算公式"></a>大气压强计算公式</h3><ul>
<li>经验公式：<br>$$<br>P_a &#x3D; P_0 \cdot \left(1 - \frac{0.0065 \cdot h}{273+T_h}\right)^{5.255}<br>$$</li>
<li>P0：标准大气压为 101325</li>
<li>h：海拔高度</li>
<li>Th：温度</li>
</ul>
<h3 id="空气密度"><a href="#空气密度" class="headerlink" title="空气密度"></a>空气密度</h3><ul>
<li>经验公式：<br>$$<br>\rho &#x3D; \frac{273P_a}{101325(273 + T_h)} \rho_0<br>$$</li>
<li>ρ：空气密度</li>
<li>Th：温度</li>
<li>ρ0：标准空气密度为1.293</li>
</ul>
<h3 id="转速"><a href="#转速" class="headerlink" title="转速"></a>转速</h3><p>$$<br>N &#x3D; 60 \sqrt{\frac{T}{\rho D_{p}^{4} C_{T}}}<br>$$</p>
<ul>
<li>T：拉力</li>
<li>ρ：空气密度</li>
<li>Dp：螺旋桨直径</li>
<li>Ct：推力系数，不同的电机不同的值</li>
</ul>
<h2 id="1-4计算转矩"><a href="#1-4计算转矩" class="headerlink" title="1.4计算转矩"></a>1.4计算转矩</h2><p>$$<br>M &#x3D; \rho D_p^5 C_M \left( \frac{N}{60} \right)^2<br>$$</p>
<ul>
<li>ρ：空气密度</li>
<li>Dp：螺旋桨直径</li>
<li>Cm：转矩系数，不同的电机不同的值</li>
<li>N：转速</li>
</ul>
<h1 id="2-计算电机的等效电流Im和等效电压Um"><a href="#2-计算电机的等效电流Im和等效电压Um" class="headerlink" title="2.计算电机的等效电流Im和等效电压Um"></a>2.计算电机的等效电流Im和等效电压Um</h1><h2 id="2-1等效电流"><a href="#2-1等效电流" class="headerlink" title="2.1等效电流"></a>2.1等效电流</h2><ul>
<li>根据目标转矩计算电机的等效电流</li>
</ul>
<p>$$<br>I_m &#x3D; \frac{M K_{v} U_{0}}{9.55(U_{0} - I_{0} R_0) + I_{0}}<br>$$</p>
<ul>
<li>M：转矩</li>
<li>Kv：电机kv值</li>
<li>U0：空载电压</li>
<li>I0：空载电流</li>
<li>R0：电机内阻</li>
</ul>
<h2 id="2-2等效电压"><a href="#2-2等效电压" class="headerlink" title="2.2等效电压"></a>2.2等效电压</h2><p>$$<br>U_m &#x3D; \left( \frac{M K_{v} U_{0}}{9.55 (U_{0} - I_{0} R_0)} + I_{0} \right) R_m + \frac{U_{0} - I_{0} R_0}{K_{v} U_{0}} N<br>$$</p>
<ul>
<li>M：转矩</li>
<li>Kv：电机Kv值</li>
<li>U0：空载电压</li>
<li>I0：空载电流</li>
<li>R0：电机内阻</li>
<li>N：转速</li>
<li>9.55：角速度与转速转化系数  将  转&#x2F;每分钟 转化成 弧度&#x2F;秒</li>
</ul>
<h1 id="计算电调相关参数"><a href="#计算电调相关参数" class="headerlink" title="计算电调相关参数"></a>计算电调相关参数</h1><h2 id="输入油门指令σ-占空比"><a href="#输入油门指令σ-占空比" class="headerlink" title="输入油门指令σ(占空比)"></a>输入油门指令σ(占空比)</h2><ul>
<li>计算电调的占空比<br>$$<br>\sigma &#x3D; \frac{U_m + I_m R_e}{U_b}<br>$$</li>
<li>Um：等效电压</li>
<li>Im：等效电流</li>
<li>Re：其它电阻，如电调导线电阻</li>
<li>Ub：电池电压</li>
</ul>
<h2 id="3-电调输入电流与输入电压"><a href="#3-电调输入电流与输入电压" class="headerlink" title="3.电调输入电流与输入电压"></a>3.电调输入电流与输入电压</h2><p>输入电流：</p>
<p>$$<br>I_e&#x3D;σ\cdot I_m<br>$$</p>
<ul>
<li>σ：占空比</li>
<li>Im：等效电流</li>
</ul>
<p>电池放电电流：</p>
<p>$$<br>I_b&#x3D;n_r\cdot I_e +I_other<br>$$</p>
<ul>
<li>Nr：电机个数</li>
<li>Ie：电调输入电流</li>
<li>Iother：其它损耗电流</li>
</ul>
<p>输入电压：</p>
<p>$$<br>U_e&#x3D;U_b-I_b \cdot R_b<br>$$<br>Ub：电池电压<br>Ib：电池放电电流<br>Rb：电源内阻</p>
<h1 id="4-悬停时间"><a href="#4-悬停时间" class="headerlink" title="4.悬停时间"></a>4.悬停时间</h1><p>$$<br>T_b &#x3D; \frac{C_b - C_{\min}}{I_b} \times \frac{60}{1000}<br>$$</p>
<ul>
<li>Cb：电池容量</li>
<li>Cmin：最小容量</li>
<li>Ib：放电电流</li>
</ul>
]]></content>
      <categories>
        <category>无人机</category>
      </categories>
  </entry>
  <entry>
    <title>解决在Vscode开发ROS没有提示</title>
    <url>/2025/10/31/%E8%A7%A3%E5%86%B3%E5%9C%A8Vscode%E5%BC%80%E5%8F%91ROS%E6%B2%A1%E6%9C%89%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<p>首先在.vscode文件夹下的c_cpp_properties.json文件修改成下图：<br><img src="/../../images/Pasted%20image%2020251031194924.png"><br>在上图的includePath中加入自己工作空间的路径</p>
]]></content>
      <categories>
        <category>无人机</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
</search>
