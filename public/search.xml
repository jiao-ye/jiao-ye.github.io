<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STM32单片机下载显示failed to erase memory</title>
    <url>/2025/09/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8B%E8%BD%BD%E6%98%BE%E7%A4%BAfailed%20to%20erase%20memory/</url>
    <content><![CDATA[<p>在焊接新的芯片后下载程序显示下图<br><img src="/../../images/Pasted%20image%2020250915165612.png"><br>错误显示无法擦除扇区，连接ST-LINKUtility显示如下：<br><img src="/../../images/Pasted%20image%2020250915170058.png"><br>发现扇区0.1被锁住，取消勾选，再点击apply就行。我买的不是全新的吗？？？？？</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>BUCK电路详解</title>
    <url>/2025/02/26/BUCK%E7%94%B5%E8%B7%AF%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="什么是BUCK电路"><a href="#什么是BUCK电路" class="headerlink" title="什么是BUCK电路"></a>什么是BUCK电路</h1><ul>
<li>在如下回路中，通过不断的开关mos管，我们可以得到这样的电压波形<br><img src="/../images/Pasted%20image%2020250226174346.png"><br><img src="/../images/Pasted%20image%2020250226174516.png"></li>
</ul>
<h2 id="有什么办法能让这个波形变得更加缓呢"><a href="#有什么办法能让这个波形变得更加缓呢" class="headerlink" title="有什么办法能让这个波形变得更加缓呢"></a>有什么办法能让这个波形变得更加缓呢</h2><ul>
<li>我们可以想到，电容两端的电压不能突变，我们加上电容试试<br><img src="/../images/Pasted%20image%2020250226175122.png"><br>可以看到波形如下：<br><img src="/../images/Pasted%20image%2020250226175229.png"></li>
<li>可以看到，当开关断开时，电压并没有降为0，这是因为当开关闭合时，电源同时给负载和电容供电，当开关断开时，电容又会给负载供电，所以此时的电压不会为0，此时来看看电流的波形<br><img src="/../images/Pasted%20image%2020250226180138.png"></li>
<li>为什么会出现这个尖端呢，我们可以联想一下电容的公式：<br>$$ i(t) &#x3D; C \frac{dV(t)}{dt} $$</li>
<li>当t(时间)无限小时，此时的i(电流)是无限大的，这就是尖端产生的原因。</li>
</ul>
<h2 id="有什么能让这个尖端变缓呢"><a href="#有什么能让这个尖端变缓呢" class="headerlink" title="有什么能让这个尖端变缓呢"></a>有什么能让这个尖端变缓呢</h2><ul>
<li><p>可以很自然的想到，电感的电流是不可以突变的，我们加上电感试试，但由于当开关断开是，电感的左侧是开路的，我们需要构成一个回路，当开关闭合时，这个回路是断开的，开关断开是，这个回路是闭合的，可以想到用一个二极管放置在回路中，这就叫异步BUCK，既然有异步，那肯定就有同步，将一个MOS管代替二极管的位置，同时将控制开关的信号接一个反相器来控制MOS管，这时，当开关打开时，信号经过反相器就会将MOS管截止，反之就会打开。</p>
</li>
<li><p>下面是同步BUCK的示例<br><img src="/../images/Pasted%20image%2020250226195201.png"></p>
</li>
<li><p>在这里电源电压设置为10V，占空比设为0.5，理论值应为5V<br><img src="/../images/Pasted%20image%2020250226195734.png"><br>可以看到与理论值相差不大</p>
</li>
</ul>
<h2 id="异步BUCK结构拓补图"><a href="#异步BUCK结构拓补图" class="headerlink" title="异步BUCK结构拓补图"></a>异步BUCK结构拓补图</h2><p><img src="/../images/Pasted%20image%2020250226201507.png"></p>
<h2 id="同步BUCK结构拓补图"><a href="#同步BUCK结构拓补图" class="headerlink" title="同步BUCK结构拓补图"></a>同步BUCK结构拓补图</h2><p><img src="/../images/Pasted%20image%2020250226201559.png"></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>电路</tag>
        <tag>DC-DC</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32时钟树</title>
    <url>/2025/05/11/STM32%E6%97%B6%E9%92%9F%E6%A0%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>在对STM32编程时，代码第一步总是要开启外设时钟使能，在数据手册上可以看到所有外设都是挂载在时钟树下，所以时钟树到底是个什么玩意？本文在此介绍。</li>
</ul>
<h1 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h1><ul>
<li>首先解释一下什么是时钟树，STM32的时钟树(Clock Tree)是指控制器内部时钟信号从源头到各个外设的分配和控制系统。它是一个复杂的网络结构，决定了CPU、总线和外设的工作频率。</li>
</ul>
<h2 id="时钟的种类"><a href="#时钟的种类" class="headerlink" title="时钟的种类"></a>时钟的种类</h2><ul>
<li>从数据手册可以看出，STM32系列的单片机又有四个基础时钟源，<strong>HSI振荡器时钟，LSI振荡器时钟，HSE振荡器时钟，HSI振荡器时钟</strong>，这四个时钟就是最基本的时钟来源，也就是时钟树的根，之后就是<strong>PLL锁相环</strong>和<strong>SYSCLK系统时钟</strong>。</li>
<li>这几者的关系可以先看成这样的关系<br><img src="/../images/Pasted%20image%2020250513211843.png"></li>
<li>我们直接查看数据手册<br><img src="/../images/Pasted%20image%2020250513212416.png"><br>可以看到外设的最高频率可以达到170M，显然可以看到这四个基础时钟都无法直接提供170M的频率，那么这170M的时钟是哪来的呢？从上面的关系图可以看出，将HSE或者HSI接入PLL就能输出170M的频率了。</li>
<li>系统时钟的来源：HSI振荡器时钟 HSE振荡器时钟 PLL锁相环  ，</li>
<li>两个次级时钟源：LSI振荡器时钟 LSE振荡器时钟</li>
</ul>
<h2 id="时钟树的框图"><a href="#时钟树的框图" class="headerlink" title="时钟树的框图"></a>时钟树的框图</h2><p><img src="/../images/Pasted%20image%2020250513213131.png"><br>乍一看很复杂，但我们不需要看这么多，我们将其简化一下，只需要看红色部分就行<br><img src="/../images/Pasted%20image%2020250513215153.png"></p>
<ul>
<li>LSI(内部低速时钟)：时钟信号由内部RC振荡电路产生，频率为32.768K</li>
<li>HSI(内部高速时钟)：时钟信号由内部RC振荡电路产生，STM32G431有两个时钟源(16M和48M)，一般用于独立看门狗</li>
<li>LSE(外部低速时钟)：时钟信号由外部晶振提供，一般为32.768K，一般用于RTC实时时钟</li>
<li>HSE(外部高速时钟)：时钟信号由外部晶振提供，范围为4-48M，主要是用该时钟</li>
<li>PLL锁相环：将时钟的信号进行放大<br> 简单介绍PLL锁相环，先看PLL的框图：<br> <img src="/../images/Pasted%20image%2020250909172639.png"><br>  鉴相器：通过比较输入输出的相位差，输出一定的电压信号<br>  低通滤波：滤除鉴相器输出的杂波<br>  压控振荡器：使输出信号的频率与低通滤波输出的频率保持一致<br>  那么我们只要在反馈通道上加上一个分频器，就能实现输出信号的放大</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32G431启用FPU与DSP库</title>
    <url>/2025/09/22/STM32G431%E5%90%AF%E7%94%A8FPU%E4%B8%8EDSP%E5%BA%93/</url>
    <content><![CDATA[<h1 id="FPU与DSP"><a href="#FPU与DSP" class="headerlink" title="FPU与DSP"></a>FPU与DSP</h1><ul>
<li>STM32的FPU是芯片内部的硬件浮点运算单元，能高速处理所有浮点计算；而DSP库则是建立在FPU等硬件特性之上的软件函数库，它提供了一系列经过极致优化的数字信号处理算法（如FFT、滤波等）。两者关系可概括为：FPU是强大的硬件基础，负责通用浮点加速；DSP库则是专业的软件加速包，针对复杂算法进行特定优化。在实际应用中，应先启用FPU获得基础性能提升，再调用DSP库来处理专门的复杂运算任务。</li>
<li>下面我们通过STM32CUBEMX + cmake  + vscode 来创建一个完整地项目</li>
</ul>
<h1 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h1><h2 id="1-新建STMG431CBT6的工程"><a href="#1-新建STMG431CBT6的工程" class="headerlink" title="1.新建STMG431CBT6的工程"></a>1.新建STMG431CBT6的工程</h2><p><img src="/../../images/Pasted%20image%2020250923155732.png"></p>
<ul>
<li>选择外部高速时钟<br><img src="/../../images/Pasted%20image%2020250923160215.png"></li>
<li>开启SWD，就是允许我们使用ST-link进行下载调试，时钟来源选择系统时钟<br><img src="/../../images/Pasted%20image%2020250923161121.png"></li>
<li>因为我们要用到串口打印相关信息，开启串口2</li>
<li><img src="/../../images/Pasted%20image%2020250923161436.png"></li>
<li>配置时钟，按照自己的晶振频率设置<br><img src="/../../images/Pasted%20image%2020250923161706.png"></li>
<li>配置相关项目相关信息<br>项目名称，开发工具，固件版本<br><img src="/../../images/Pasted%20image%2020250923161903.png"><br>生成源文件和头文件 ，生成项目<br><img src="/../../images/Pasted%20image%2020250923162323.png"></li>
</ul>
<h2 id="2-用VSCODE打开并编译看是否成功"><a href="#2-用VSCODE打开并编译看是否成功" class="headerlink" title="2.用VSCODE打开并编译看是否成功"></a>2.用VSCODE打开并编译看是否成功</h2><p>导入Cmake项目，选择刚生成的文件打开，直接导入即可<br><img src="/../../images/Pasted%20image%2020250923165558.png"><br>点击编译，输出如下信息显示成功<br><img src="/../../images/Pasted%20image%2020250923165728.png"></p>
<h2 id="3-开启FPU并且添加DSP库"><a href="#3-开启FPU并且添加DSP库" class="headerlink" title="3.开启FPU并且添加DSP库"></a>3.开启FPU并且添加DSP库</h2><ul>
<li>回到CUBEMX<br><img src="/../../images/Pasted%20image%2020250923170055.png"></li>
<li>找到DSP库，并且勾选上，可能下载会比较慢<br><img src="/../../images/Pasted%20image%2020250923170334.png"><br>返回，并且勾选上添加DSP库，生成代码<br><img src="/../../images/Pasted%20image%2020250923171004.png"><br>返回Vscode看到有如下文件则添加成功<br><img src="/../../images/Pasted%20image%2020250923171138.png"><br>接下来在CMake文件中如下位置添加两行代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/Drivers/CMSIS/DSP/Lib/GCC/libarm_cortexM4lf_math.a</span><br><span class="line">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/Drivers/CMSIS/DSP/Include</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250923171646.png"><br>到此，工程创建成功</p>
<h1 id="测试工程"><a href="#测试工程" class="headerlink" title="测试工程"></a>测试工程</h1><p>为了方便输出信息，我们将串口重定向，在usart.c文件中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef __GNUC__</span><br><span class="line"></span><br><span class="line">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  // 阻塞方式打印 -&gt; 串口2</span><br><span class="line"></span><br><span class="line">  HAL_UART_Transmit(&amp;huart2, (uint8_t *)&amp;ch, 1, 0xFFFF);</span><br><span class="line"></span><br><span class="line">  return ch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>&#x3D;&#x3D;注意要在gcc-arm-none-eabi.cmake文件如下位置加入-u_printf_float&#x3D;&#x3D;<br><img src="/../../images/Pasted%20image%2020250925165625.png"></li>
</ul>
<p>测试代码，注意需要包含stdio头文件<br><img src="/../../images/Pasted%20image%2020250923172715.png"><br>该插件的下载按钮如下<br><img src="/../../images/Pasted%20image%2020250923173120.png"><br>&#x3D;&#x3D;注意，必须加“\n”,不然会有莫名的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;hello\n&quot;);</span><br></pre></td></tr></table></figure>
<p>调试信息如下：<br><img src="/../../images/Pasted%20image%2020250925170045.png"><br>成功&#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode开发STM32G431使用串口重定向</title>
    <url>/2025/06/03/Vscode%E5%BC%80%E5%8F%91STM32G431%E4%BD%BF%E7%94%A8%E4%B8%B2%E5%8F%A3%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<ul>
<li>在Vscode中使用STM32 VS Code Extension来开发STM32G431不同于keil，在keil中，我们只要勾选MicroLIB就能实现串口重定向<br><img src="/../images/Pasted%20image%2020250603222055.png"></li>
<li>在Vscode中我们要在STM32cubemx生成的代码下，在usart.c文件中加入如下代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;//包含头文件</span><br><span class="line"></span><br><span class="line">#ifdef __GNUC__</span><br><span class="line"></span><br><span class="line">  #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">  #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> PUTCHAR_PROTOTYPE</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  HAL_UART_Transmit(&amp;huart2,(uint8_t *)&amp;ch,1,0xFFFF);//阻塞方式打印</span><br><span class="line"></span><br><span class="line">  return ch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：使用printf函数时，必须在末尾加上\r\n，否则无法输出</p>
]]></content>
      <categories>
        <category>STM32</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>STM32G431</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建个人博客推送至github</title>
    <url>/2025/02/21/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8E%A8%E9%80%81%E8%87%B3github/</url>
    <content><![CDATA[<h1 id="安装git与Nodejs"><a href="#安装git与Nodejs" class="headerlink" title="安装git与Nodejs"></a>安装git与Nodejs</h1><ul>
<li><p>在Windows上安装Git，可以从Git官网直接<a href="https://git-scm.com/downloads%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8C%89%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9%E5%AE%89">https://git-scm.com/downloads，然后按默认选项安</a><br>装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就<br>说明Git安装成功。<br><img src="/../../images/Pasted%20image%2020250221215415.png"></p>
</li>
<li><p>在Git中绑定Github账号，打开“Git Bash”，在命令框中依次输入两行命令：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br><span class="line"># 其中Your Name和email@example.com替换成github账户名和邮箱</span><br></pre></td></tr></table></figure>
<ul>
<li>安装NodeJS<br>网址 <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> 并配置环境变量。</li>
<li>安装之后可以输入以下命令查看是否安装成功。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250221220038.png"></p>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul>
<li>新建文件夹，在该文件夹下打开”git bach here“。<br><img src="/../../images/Pasted%20image%2020250221220553.png"></li>
<li>在命令行执行下列命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<ul>
<li>执行完成后，运行 hexo server 命令，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就能够预览效果了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250221220910.png"></p>
<h1 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h1><ul>
<li>我用的是NEXT主题：<a href="https://github.com/next-theme/hexo-theme-next%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%9C%A8myBlog/themes%E8%B7%AF%E5%BE%84%E4%B8%8B%E3%80%82%E7%84%B6%E5%90%8E%E6%89%93%E5%BC%80_config.yml%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%A6%82%E4%B8%8B%E3%80%82">https://github.com/next-theme/hexo-theme-next，下载完成后解压在myBlog\themes路径下。然后打开_config.yml文件修改如下。</a><br><img src="/../../images/Pasted%20image%2020250221221700.png"><br>这里为了简便我将解压后的文件重命名为next，保存之后刷新 <a href="http://localhost:4000/">http://localhost:4000</a> 页面，主题就已经更改完成。</li>
</ul>
<h1 id="修改next主题配置"><a href="#修改next主题配置" class="headerlink" title="修改next主题配置"></a>修改next主题配置</h1><ul>
<li>详细配置请见</li>
</ul>
<h1 id="将博客部署在github上"><a href="#将博客部署在github上" class="headerlink" title="将博客部署在github上"></a>将博客部署在github上</h1><ul>
<li>在github上建立一个新仓库，在这里注意仓库名一定要是： 用户名.github.io，如我的用户名是jiao-ye，那么我的新仓库名就为jiao-ye.github.io</li>
<li>配置 SSH key ，要使用 git 工具首先要配置一下SSH key，将本地仓库能连接远程仓库，输入下列命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#email@example.com替换成github邮箱</span><br></pre></td></tr></table></figure>
<p>按照提示完成后便可以生成ssh key。<br>查看ssh key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/Pasted%20image%2020250221223544.png"><br>复制输出的ssh key，在github上建立新的ssh key<br><img src="/../../images/Pasted%20image%2020250221223704.png"><br><img src="/../../images/Pasted%20image%2020250221223713.png"></p>
<ul>
<li>将本地仓库与远程仓库连接起来，打开_config.yml文件进行如下修改<br><img src="/../../images/Pasted%20image%2020250221223919.png"><br><img src="/../../images/Pasted%20image%2020250221223957.png"></li>
<li>安装部署插件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ul>
<li>执行如下两条指令生成与部署</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g # 生成</span><br><span class="line">hexo d # 部署到Github上</span><br></pre></td></tr></table></figure>
<ul>
<li>用浏览器输入 用户名.github.io 就可以访问自己的个人博客了</li>
</ul>
<h1 id="编写shell脚本方便部署"><a href="#编写shell脚本方便部署" class="headerlink" title="编写shell脚本方便部署"></a>编写shell脚本方便部署</h1><ul>
<li>在myBlog下新建deploy.sh脚本，粘贴下列代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成静态文件</span><br><span class="line">hexo clean &amp;&amp; hexo generate</span><br><span class="line"></span><br><span class="line"># 部署到 GitHub Pages</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>给与权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+x deploy.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>双击deploy.sh即可一键部署<br><img src="/../../images/Pasted%20image%2020250221224633.png"></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>Obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题的使用</title>
    <url>/2025/02/22/next%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="主题类型设置"><a href="#主题类型设置" class="headerlink" title="主题类型设置"></a>主题类型设置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes 主题类型设置</span><br><span class="line"></span><br><span class="line"># scheme: Muse</span><br><span class="line"></span><br><span class="line">#scheme: Mist</span><br><span class="line"></span><br><span class="line">#scheme: Pisces</span><br><span class="line"></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
<p>有四个类型</p>
<h1 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"></span><br><span class="line">  home: / || fa fa-home #主页</span><br><span class="line"></span><br><span class="line">  #about: /about/ || fa fa-user</span><br><span class="line"></span><br><span class="line">  tags: /tags/ || fa fa-tags #标签页</span><br><span class="line"></span><br><span class="line">  categories: /categories/ || fa fa-th #种类页</span><br><span class="line"></span><br><span class="line">  archives: /archives/ || fa fa-archive #日志页</span><br><span class="line"></span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line"></span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line"></span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>
<p>打开后，在myBlog\source路径下新建tags与categories文件夹，并在文件夹下建立index.md文件，<br>tags下index文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: 标签</span><br><span class="line"></span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line"></span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>categories下index文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: 种类</span><br><span class="line"></span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line"></span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1 id="修改主页头像"><a href="#修改主页头像" class="headerlink" title="修改主页头像"></a>修改主页头像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line"></span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line"></span><br><span class="line">  url: /images/jiaoye.gif #在这里填入你头像的路径 头像格式为215 X 215</span><br><span class="line"></span><br><span class="line">  # If true, the avatar will be displayed in circle.</span><br><span class="line"></span><br><span class="line">  rounded: false</span><br><span class="line"></span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line"></span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>
<h1 id="开启搜索功能"><a href="#开启搜索功能" class="headerlink" title="开启搜索功能"></a>开启搜索功能</h1><ul>
<li>安装插件<code>hexo-generator-searchdb</code>,执行以下命令:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<ul>
<li>修改hexo&#x2F;config.yml配置内容，新增以下内容到任意位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑 主题配置文件，启用本地搜索功能：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">enable: true</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>串联谐振与并联谐振</title>
    <url>/2025/03/03/%E4%B8%B2%E8%81%94%E8%B0%90%E6%8C%AF%E4%B8%8E%E5%B9%B6%E8%81%94%E8%B0%90%E6%8C%AF/</url>
    <content><![CDATA[<h1 id="什么是谐振？"><a href="#什么是谐振？" class="headerlink" title="什么是谐振？"></a>什么是谐振？</h1><h3 id="RLC串联谐振"><a href="#RLC串联谐振" class="headerlink" title="RLC串联谐振"></a>RLC串联谐振</h3><ul>
<li><p>对于一个RLC串联电路，如果端电压与端电流同相位，则称该电路发生了谐振<br><img src="/../images/Pasted%20image%2020250303235346.png"></p>
</li>
<li><p>电路的阻抗为<br> $$ Z &#x3D; R + j\left( \omega L - \frac{1}{\omega C} \right) $$<br> 从上面可以看出阻抗具有虚部，那么端口电压与端口电流的相位肯定不是相同的，相差一个阻抗角</p>
</li>
<li><p>我们知道，流经电阻的电压和电流是相位相同的，那么我们是否可以把该电路的阻抗等效成一个电阻呢，当然可以，只需要令<br> $$ \left( \omega L - \frac{1}{\omega C} \right)&#x3D;0 $$<br> 此时该电路的阻抗就等效为R</p>
</li>
<li><p>可以求得：<br> $$ w &#x3D; \frac{1}{\sqrt{LC}} $$</p>
</li>
</ul>
<p> 当上式成立时，此时该电路就发生了谐振。</p>
<ul>
<li>如果我们变化这个频率，电路会怎样变化，w增大，可以推出<br>$$ \left( \omega L - \frac{1}{\omega C} \right)&gt;0 $$<br> 那么此时的阻抗角<br> $$\theta &#x3D; \arctan\left(\frac{X}{R}\right)&gt;0$$<br> 可以得出电压超前电流，那么此时该电路呈现出感性，反之则呈现出容性，此时电容与电感的总电压为0，但电容与电感两端的电压却不是为0，而是具有这样的特点：大小相同，方向相反</li>
</ul>
<h3 id="RLC并联谐振"><a href="#RLC并联谐振" class="headerlink" title="RLC并联谐振"></a>RLC并联谐振</h3><ul>
<li>对于RLC并联谐振也是一样的，为了方便，我们用导纳来表示<br><img src="/../images/Pasted%20image%2020250304003015.png"></li>
<li>电路的导纳为<br> $$ Y &#x3D; G + j\left( \omega C - \frac{1}{\omega L} \right) $$<br> 一样的我们令<br> $$ \left( \omega C - \frac{1}{\omega L} \right)&#x3D;0 $$<br> 此时电路的导纳就等效为G，端电流与端电压的相位就相同了</li>
<li>同样可以求得<br>  $$ w &#x3D; \frac{1}{\sqrt{LC}} $$</li>
<li>如果我们改变这个频率，令w增大，那么可以推出<br>   $$ \left( \omega C - \frac{1}{\omega L} \right)&gt;0 $$<br>   此时电流的相位超前电压，电路呈现容性，反之呈现感性。此时电容与电感的总电流为0，但电容与电感所在的支路电流却不是为0，而是具有这样的特点：大小相同，方向相反</li>
</ul>
<h2 id="谐振的特性"><a href="#谐振的特性" class="headerlink" title="谐振的特性"></a>谐振的特性</h2><ul>
<li>对于RLC串联电路，我们可由阻抗的模值等于<br>$$|Z| &#x3D; \sqrt{R^2 + X^2}$$<br>此时的电流等于<br>$$I &#x3D; \frac{U}Z$$<br>可知当阻抗最小时，电流最大，那么什么时候阻抗最小，如果X等于0，那么|Z|就最小，也就是发生谐振的时候，所以RLC串联电路发生谐振时，电路的电流是最大的</li>
<li>同理我们可以推出RLC并联电路发生谐振时，电路的电流是最小的</li>
</ul>
<h2 id="品质因数"><a href="#品质因数" class="headerlink" title="品质因数"></a>品质因数</h2><ul>
<li>在RLC串联谐振中，品质因数的定义是电容或电感的电压与电源的比值<br>$$Q &#x3D; \frac{w L}{R} &#x3D; \frac{1}{w C R}&#x3D;\frac{1}{R} \sqrt{\frac{L}{C}}$$<br>可以看到电路的品质因数由RLC的参数决定，如果Q大于0，则说明电容&#x2F;电感两端的电压大于电源电压，这就叫做”过电压“，在实际中，我们应该避免过电压的产生</li>
<li>在RLC并联谐振中，品质因数的定义是电容或电感的支路电流与干路电流的比值 $$<br>Q &#x3D; \frac{1}{G} \sqrt{\frac{C}{L}}$$<br>可以看到电路的品质因数也是由RLC的参数决定，如果Q大于0，则说明电容&#x2F;电感的支路电流大于干路电流，这就叫做”过电流“</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Cmake+hal库开发STM32无法通过printf打印浮点数</title>
    <url>/2025/09/16/%E4%BD%BF%E7%94%A8Cmake+hal%E5%BA%93%E5%BC%80%E5%8F%91STM32%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87printf%E6%89%93%E5%8D%B0%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<p>在开发STM32中，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    printf(&quot;angle = %d&quot;, angle);</span><br><span class="line"></span><br><span class="line">    printf(&quot;angle = %f\n&quot;, angle_f);</span><br><span class="line">  注意，最后打印字符时必须要加上换行符，否则会出错</span><br></pre></td></tr></table></figure>
<p>输出界面：<br><img src="/../images/Pasted%20image%2020250916104932.png"><br>可以看到浮点数并没有被打印出来，我们只需要在.cmake文件中加入-u_printf_float<br><img src="/../images/Pasted%20image%2020250916105907.png"><br>重新编译下载<br><img src="/../images/Pasted%20image%2020250916110026.png"><br>正常打印浮点数，但此时占用的FLASH较多，建议不需要时关闭</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>解决STM32G431BOOT0与IIC冲突问题</title>
    <url>/2025/06/04/%E8%A7%A3%E5%86%B3STM32G431BOOT0%E4%B8%8EIIC%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>在STM32G431中，启动时选择主Flash启动，此时需要将BOOT0引脚拉低为低电平，但此时BOOT0引脚作为IIC外挂了4.7k电阻，此时不可能将引脚拉低。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>STM32G431</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Obsidian来编写hexo博客</title>
    <url>/2025/02/21/%E4%BD%BF%E7%94%A8Obsidian%E6%9D%A5%E7%BC%96%E5%86%99hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="下载Obsidian"><a href="#下载Obsidian" class="headerlink" title="下载Obsidian"></a>下载Obsidian</h1><ul>
<li>在官网下载Obsidian：<a href="https://obsidian.md/">https://obsidian.md/</a><br><img src="/../../images/Pasted%20image%2020250221230923.png"><br>按照提示安装，最好将目标位置改为D盘</li>
<li>安装完成，选择打开myBlog文件夹<br><img src="/../../images/Pasted%20image%2020250221231158.png"></li>
</ul>
<h1 id="配置Obsidian"><a href="#配置Obsidian" class="headerlink" title="配置Obsidian"></a>配置Obsidian</h1><ul>
<li>点击Obsidian的设置<br><img src="/../../images/Pasted%20image%2020250221231614.png"></li>
<li>点击文件与链接，忽略以下文件<br><img src="/../../images/Pasted%20image%2020250221231806.png"></li>
<li>在myBlog\source下新建images文件夹，将内部链接类型改为基于当前笔记的相对路径，关闭wiki链接，将附件默认存放路径改为指定的附件文件夹，将附件文件夹路径改为source&#x2F;images<br><img src="/../../images/Pasted%20image%2020250221232138.png"></li>
<li>将新建笔记的存放位置改为指定的附件文件夹，将存放新建笔记的文件<br><img src="/../../images/Pasted%20image%2020250221232446.png"></li>
</ul>
<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><ul>
<li>关闭安全模式，在插件市场下载如下四个插件<br><img src="/../images/Pasted%20image%2020250222161719.png"></li>
</ul>
<h2 id="git、float-toc、tree下载无需配置"><a href="#git、float-toc、tree下载无需配置" class="headerlink" title="git、float toc、tree下载无需配置"></a>git、float toc、tree下载无需配置</h2><h2 id="Shell插件配置"><a href="#Shell插件配置" class="headerlink" title="Shell插件配置"></a>Shell插件配置</h2><ul>
<li>点击New shell command，创建新的命令</li>
<li>写入start deploy.sh命令，该脚本在已经在<a href="/2025/02/21/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8E%A8%E9%80%81%E8%87%B3github/" title="hexo搭建个人博客推送至github">hexo搭建个人博客推送至github</a>中创建<br> <img src="/../images/Pasted%20image%2020250222162125.png"></li>
<li>点击执行按钮，就会自动部署到远程仓库</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
        <tag>Obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>无人机悬停时间计算方法</title>
    <url>/2025/10/23/%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%82%AC%E5%81%9C%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="轴距"><a href="#轴距" class="headerlink" title="轴距"></a>轴距</h1><ul>
<li>轴距：对角线方向上两个电机中心之间的直线距离，轴距越短，对飞控的精度要求就更高</li>
</ul>
<h1 id="拉力"><a href="#拉力" class="headerlink" title="拉力"></a>拉力</h1><ul>
<li>由整机的重量来计算单个螺旋桨需要的拉力</li>
</ul>
<p>$$<br>T &#x3D; \frac{G}{n}<br>$$</p>
<ul>
<li>G是重力，n是螺旋桨个数</li>
</ul>
<h1 id="电机转速N和螺旋桨转矩M"><a href="#电机转速N和螺旋桨转矩M" class="headerlink" title="电机转速N和螺旋桨转矩M"></a>电机转速N和螺旋桨转矩M</h1><h2 id="计算转速N"><a href="#计算转速N" class="headerlink" title="计算转速N"></a>计算转速N</h2><h3 id="大气压强计算公式"><a href="#大气压强计算公式" class="headerlink" title="大气压强计算公式"></a>大气压强计算公式</h3><ul>
<li>经验公式：<br>$$<br>P_a &#x3D; P_0 \cdot \left(1 - \frac{0.0065 \cdot h}{273+T_h}\right)^{5.255}<br>$$</li>
<li>P0：标准大气压为 101325</li>
<li>h：海拔高度</li>
<li>Th：温度</li>
</ul>
<h3 id="空气密度"><a href="#空气密度" class="headerlink" title="空气密度"></a>空气密度</h3><ul>
<li>经验公式：<br>$$<br>\rho &#x3D; \frac{273P_a}{101325(273 + T_h)} \rho_0<br>$$</li>
<li>ρ：空气密度</li>
<li>Th：温度</li>
<li>ρ0：标准空气密度为1.293</li>
</ul>
<h3 id="转速"><a href="#转速" class="headerlink" title="转速"></a>转速</h3><p>$$<br>N &#x3D; 60 \sqrt{\frac{T}{\rho D_{p}^{4} C_{T}}}<br>$$</p>
<ul>
<li>T：拉力</li>
<li>ρ：空气密度</li>
<li>Dp：螺旋桨直径</li>
<li>Ct：推力系数，不同的电机不同的值</li>
</ul>
<h2 id="计算转矩"><a href="#计算转矩" class="headerlink" title="计算转矩"></a>计算转矩</h2><p>$$<br>M &#x3D; \rho D_p^5 C_M \left( \frac{N}{60} \right)^2<br>$$</p>
<ul>
<li>ρ：空气密度</li>
<li>Dp：螺旋桨直径</li>
<li>Cm：转矩系数，不同的电机不同的值</li>
<li>N：转速</li>
</ul>
<h1 id="计算电机的等效电流Im和等效电压Um"><a href="#计算电机的等效电流Im和等效电压Um" class="headerlink" title="计算电机的等效电流Im和等效电压Um"></a>计算电机的等效电流Im和等效电压Um</h1><h2 id="等效电流"><a href="#等效电流" class="headerlink" title="等效电流"></a>等效电流</h2><ul>
<li>根据目标转矩计算电机的等效电流</li>
</ul>
<p>$$<br>I_m &#x3D; \frac{M K_{v} U_{0}}{9.55(U_{0} - I_{0} R_0) + I_{0}}<br>$$</p>
<ul>
<li>M：转矩</li>
<li>Kv：电机kv值</li>
<li>U0：空载电压</li>
<li>I0：空载电流</li>
<li>R0：电机内阻</li>
</ul>
<h2 id="等效电压"><a href="#等效电压" class="headerlink" title="等效电压"></a>等效电压</h2><p>$$<br>U_m &#x3D; \left( \frac{M K_{v} U_{0}}{9.55 (U_{0} - I_{0} R_0)} + I_{0} \right) R_m + \frac{U_{0} - I_{0} R_0}{K_{v} U_{0}} N<br>$$</p>
<ul>
<li>M：转矩</li>
<li>Kv：电机Kv值</li>
<li>U0：空载电压</li>
<li>I0：空载电流</li>
<li>R0：电机内阻</li>
<li>N：转速</li>
<li>9.55：角速度与转速转化系数  将  转&#x2F;每分钟 转化成 弧度&#x2F;秒</li>
</ul>
<h1 id="计算电调相关参数"><a href="#计算电调相关参数" class="headerlink" title="计算电调相关参数"></a>计算电调相关参数</h1><h2 id="输入油门指令σ-占空比"><a href="#输入油门指令σ-占空比" class="headerlink" title="输入油门指令σ(占空比)"></a>输入油门指令σ(占空比)</h2><ul>
<li>计算电调的占空比<br>$$<br>\sigma &#x3D; \frac{U_m + I_m R_e}{U_b}<br>$$</li>
<li>Um：等效电压</li>
<li>Im：等效电流</li>
<li>Re：其它电阻，如电调导线电阻</li>
<li>Ub：电池电压</li>
</ul>
<h2 id="电调输入电流与输入电压"><a href="#电调输入电流与输入电压" class="headerlink" title="电调输入电流与输入电压"></a>电调输入电流与输入电压</h2><p>输入电流：</p>
<p>$$<br>I_e&#x3D;σ\cdot I_m<br>$$</p>
<ul>
<li>σ：占空比</li>
<li>Im：等效电流</li>
</ul>
<p>电池放电电流：</p>
<p>$$<br>I_b&#x3D;n_r\cdot I_e +I_other<br>$$</p>
<ul>
<li>Nr：电机个数</li>
<li>Ie：电调输入电流</li>
<li>Iother：其它损耗电流</li>
</ul>
<p>输入电压：</p>
<p>$$<br>U_e&#x3D;U_b-I_b \cdot R_b<br>$$<br>Ub：电池电压<br>Ib：电池放电电流<br>Rb：电源内阻</p>
<h1 id="悬停时间"><a href="#悬停时间" class="headerlink" title="悬停时间"></a>悬停时间</h1><p>$$<br>T_b &#x3D; \frac{C_b - C_{\min}}{I_b} \times \frac{60}{1000}<br>$$</p>
<ul>
<li>Cb：电池容量</li>
<li>Cmin：最小容量</li>
<li>Ib：放电电流</li>
</ul>
]]></content>
      <categories>
        <category>无人机</category>
      </categories>
  </entry>
</search>
